---
title: Netball Manurewa Texture - Thermal Inspection
---
<style>
    #viewer-container {
        width: 100%;    /* Takes full width of parent */
        height: 600px;  /* Fixed reasonable height */
        position: relative;
        margin: 0 auto; /* Centers the container */
    }

    .viewer-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
        display: flex;
        gap: 10px;
    }

    .control-button {
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        padding: 5px 10px;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .control-button:hover {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
    }
</style>

<div class="model-viewer-wrapper">
    <div class="container">
        <div id="viewer-container" class="model-viewer-container">
            <div class="viewer-controls">
                <button class="control-button" onclick="setOrbitMode()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M12 2a10 10 0 0 1 10 10"></path>
                    </svg>
                    Orbit
                </button>
                <button class="control-button" onclick="setPanMode()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M5 9l7-7 7 7"></path>
                        <path d="M5 15l7 7 7-7"></path>
                    </svg>
                    Pan
                </button>
                <button class="control-button" onclick="setZoomMode()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="M21 21l-4.35-4.35"></path>
                        <path d="M11 8v6M8 11h6"></path>
                    </svg>
                    Zoom
                </button>
                <div class="measurement-control">
                    <button class="control-button" onclick="toggleMeasureMenu()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M2 12h20M2 12v-2M22 12v-2M7 12v-5M12 12V5M17 12V7"></path>
                        </svg>
                        Measure
                    </button>
                    <div class="measure-menu" id="measureMenu">
                        <button onclick="setDistanceMeasure()">Distance</button>
                        <button onclick="setAngleMeasure()">Angle</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    let scene, camera, renderer, controls;
    let currentMode = 'orbit';
    let measurementMode = 'none';
    let selectedPoints = [];
    let measurementLine;
    let measurementText;
    let dynamicLine; // For showing line while measuring
    let pointMarkers = []; // For showing selected points

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const container = document.getElementById('viewer-container');
        const aspect = container.clientWidth / container.clientHeight;

        // Update camera with correct aspect ratio
        camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
        camera.position.z = 5;

        // Update renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        // Updated controls setup
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.panSpeed = 1.0;
        controls.enableZoom = true;
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.PAN,
            RIGHT: THREE.MOUSE.DOLLY
        };

        // Load GLB model
        const loader = new THREE.GLTFLoader();
        loader.load(
            '{{ site.baseurl }}/models/NetballThermal.glb',
            function(gltf) {
                const model = gltf.scene;
                scene.add(model);
                
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.z = maxDim * 2;
                controls.target.copy(center);
            },
            function(xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function(error) {
                console.error('Error loading model:', error);
            }
        );

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 1, 0);
        scene.add(directionalLight);

        // Add click event listener for measurements
        renderer.domElement.addEventListener('click', onModelClick);
        renderer.domElement.addEventListener('mousemove', onMouseMove);

        animate();
    }

    // Viewing mode controls
    function setOrbitMode() {
        currentMode = 'orbit';
        measurementMode = 'none';
        controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
    }

    function setPanMode() {
        currentMode = 'pan';
        measurementMode = 'none';
        controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
    }

    function setZoomMode() {
        currentMode = 'zoom';
        measurementMode = 'none';
        controls.mouseButtons.LEFT = THREE.MOUSE.DOLLY;
    }

    // Measurement controls
    function toggleMeasureMenu() {
        const menu = document.getElementById('measureMenu');
        menu.classList.toggle('show');
    }

    function setDistanceMeasure() {
        measurementMode = 'distance';
        currentMode = 'measure';
        selectedPoints = [];
        clearMeasurement();
        toggleMeasureMenu();
    }

    function setAngleMeasure() {
        measurementMode = 'angle';
        currentMode = 'measure';
        selectedPoints = [];
        clearMeasurement();
        toggleMeasureMenu();
    }

    function createPointMarker(position) {
        const geometry = new THREE.SphereGeometry(0.1);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.copy(position);
        scene.add(sphere);
        pointMarkers.push(sphere);
        return sphere;
    }

    function clearMeasurement() {
        if (measurementLine) scene.remove(measurementLine);
        if (measurementText) scene.remove(measurementText);
        if (dynamicLine) scene.remove(dynamicLine);
        pointMarkers.forEach(marker => scene.remove(marker));
        pointMarkers = [];
    }

    function onModelClick(event) {
        if (measurementMode === 'none') return;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            const point = intersects[0].point;
            createPointMarker(point);
            selectedPoints.push(point);

            if (measurementMode === 'distance') {
                if (selectedPoints.length === 2) {
                    showDistance();
                    // Don't reset measurement mode, allow continuous measurements
                    selectedPoints = [];
                    if (dynamicLine) {
                        scene.remove(dynamicLine);
                        dynamicLine = null;
                    }
                }
            } else if (measurementMode === 'angle') {
                if (selectedPoints.length === 3) {
                    showAngle();
                    // Don't reset measurement mode, allow continuous measurements
                    selectedPoints = [];
                    if (dynamicLine) {
                        scene.remove(dynamicLine);
                        dynamicLine = null;
                    }
                }
            }
        }
    }

    function onMouseMove(event) {
        if (measurementMode === 'none' || selectedPoints.length === 0) return;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            updateDynamicLine(intersects[0].point);
        }
    }

    function updateDynamicLine(currentPoint) {
        if (dynamicLine) scene.remove(dynamicLine);

        if (measurementMode === 'distance') {
            const points = [selectedPoints[0], currentPoint];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00, dashSize: 1, gapSize: 1 });
            dynamicLine = new THREE.Line(geometry, material);
            scene.add(dynamicLine);
        } else if (measurementMode === 'angle' && selectedPoints.length === 2) {
            const points = [selectedPoints[0], selectedPoints[1], selectedPoints[0], currentPoint];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
            dynamicLine = new THREE.Line(geometry, material);
            scene.add(dynamicLine);
        }
    }

    function showDistance() {
        const start = selectedPoints[0];
        const end = selectedPoints[1];
        const distance = start.distanceTo(end) * 100; // Convert to centimeters

        const geometry = new THREE.BufferGeometry().setFromPoints(selectedPoints);
        const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
        measurementLine = new THREE.Line(geometry, material);
        scene.add(measurementLine);

        const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
        const textSprite = createTextSprite(`${distance.toFixed(1)} cm`);
        textSprite.position.copy(midPoint);
        measurementText = textSprite;
        scene.add(textSprite);
    }

    function showAngle() {
        const vertex = selectedPoints[0];
        const point1 = selectedPoints[1];
        const point2 = selectedPoints[2];

        const vector1 = new THREE.Vector3().subVectors(point1, vertex);
        const vector2 = new THREE.Vector3().subVectors(point2, vertex);
        const angle = vector1.angleTo(vector2) * (180 / Math.PI);

        const geometry = new THREE.BufferGeometry().setFromPoints([vertex, point1, vertex, point2]);
        const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
        measurementLine = new THREE.Line(geometry, material);
        scene.add(measurementLine);

        const textSprite = createTextSprite(`${angle.toFixed(1)}Â°`);
        textSprite.position.copy(vertex);
        measurementText = textSprite;
        scene.add(textSprite);

        measurementMode = 'none';
        selectedPoints = [];
    }

    function createTextSprite(message) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Get device pixel ratio
        const pixelRatio = window.devicePixelRatio || 1;
        
        // Base sizes
        const fontSize = 10 * pixelRatio;  // Scale font size
        const padding = 6 * pixelRatio;    // Scale padding
        const borderRadius = 4 * pixelRatio;  // Scale border radius
        
        // Set font first to measure text
        context.font = `Bold ${fontSize}px Arial`;
        const metrics = context.measureText(message);
        
        // Calculate dimensions
        const textHeight = fontSize;
        
        // Set high-resolution canvas size
        canvas.width = (metrics.width + (padding * 2));
        canvas.height = (textHeight + (padding * 2));
        
        // Scale canvas by pixel ratio
        canvas.style.width = canvas.width / pixelRatio + 'px';
        canvas.style.height = canvas.height / pixelRatio + 'px';
        
        // Scale context for high DPI
        context.scale(pixelRatio, pixelRatio);
        
        // Draw background
        context.fillStyle = 'white';
        context.beginPath();
        context.roundRect(0, 0, canvas.width/pixelRatio, canvas.height/pixelRatio, borderRadius/pixelRatio);
        context.fill();
        
        // Draw text
        context.font = `Bold ${fontSize/pixelRatio}px Arial`;
        context.fillStyle = '#0066cc';
        context.textBaseline = 'middle';
        context.textAlign = 'center';
        context.fillText(message, canvas.width/(2*pixelRatio), canvas.height/(2*pixelRatio));

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();  // Add anisotropic filtering
        
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            sizeAttenuation: false,
            depthTest: false
        });

        const sprite = new THREE.Sprite(spriteMaterial);
        
        const scaleFactor = 0.005;
        sprite.scale.set(
            scaleFactor * canvas.width/pixelRatio,
            scaleFactor * canvas.height/pixelRatio,
            1
        );
        
        sprite.renderOrder = 999;
        
        return sprite;
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        const container = document.getElementById('viewer-container');
        const aspect = container.clientWidth / container.clientHeight;
        
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
        
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // Event listeners
    window.addEventListener('resize', onWindowResize, false);
    init();
</script>
